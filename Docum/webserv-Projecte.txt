Plan de Proyecto: webserv C++98

Calendari:
27/12 Sayer: unir documents de proposta de treball (.pdf i .txt)
29/12 individualment, estudiar docum (subject, HTTP1.1, RFCs, ...) i fer proposta classes .hpp
30/12 10:00 reunió posada en comú i completar .hpp (Clases Request, Response, Config).
	--> Hem reorganitzat assignacions
	--> Reescrit aquest document
	--> Decidit que cadascú prepari el(s) hpp q li corresponguin i els pugi a main


-----------------------------------------------------------------------------------------------
Descripción:
Webserv es un servidor HTTP básico en C++98. Debes implementar tu propio servidor web capaz de:
- Servir páginas estáticas
- Manejar métodos GET, POST, DELETE
- Ejecutar CGI (principalmente para scripts PHP o Python)
- Gestionar múltiples conexiones simultáneas (I/O multiplexing con `poll`, `select` o `epoll`)
- Parsear archivos de configuración (tipo Nginx)
- Manejar timeouts y errores HTTP
En webserv, el "backend" y el "servidor" son básicamente lo mismo: todo es C++ manejando sockets y HTTP. El "frontend" es mínimo (solo HTML/CSS de prueba).

Objetivo: Crear un servidor HTTP propio, no bloqueante, compatible con HTTP/1.1 y CGI.
Restricciones: C++98 estricto, sin librerías externas (Boost, etc.), gestión de memoria manual.


1. Arquitectura Técnica (Lo que hay que programar)
No dividiremos el trabajo en Front/Back. Dividiremos el servidor en 3 módulos lógicos para trabajar en paralelo:
● Redes (Sockets & I/O): Uso de socket, bind, listen. Clave: Multiplexación I/O no bloqueante con poll() (o epoll/kqueue). Un solo hilo para todo.
● Protocolo (HTTP): Lectura de RFCs. Parseo de texto crudo (GET /index.html...) y gestión de métodos (GET, POST, DELETE) y errores.
● CGI (Ejecución dinámica): Uso de fork, execve y pipe para ejecutar scripts (.php, .py) y devolver su salida.

2. División recomendada. Reparto de Roles (Equipo de 3, 3 partes paralelas). 
Para aprender todos de todo, el diseño inicial (.hpp) lo hacemos juntos. Luego nos separamos:

3. Estrategia de Trabajo: "Desarrollo Aislado"
Para no bloquearnos unos a otros, trabajaremos con Mocks (simulaciones) hasta la integración final:
1. Reunión CERO (CRÍTICA): Definir juntos los archivos .hpp (Clases Request, Response, Config). Es el contrato que todos debemos respetar.
2. Parser (Solo): Crea un main de pruebas con strings de texto inventados para probar su parseo. No necesita red.
3. Lógica (Solo): Crea un main donde se inventa objetos Request ya limpios para probar si borra archivos o ejecuta el CGI.
4. Core (Solo): Hace que el servidor responda "HOLA MUNDO" a todo, para probar que aguanta 1000 conexiones simultáneas (stress test con telnet o siege).

4. Cronograma "Navideño" (Estimación: 6-8 Semanas)
Fase 1: Navidad y Año Nuevo (Diseño y Lectura)
● Actividad: Poca carga de código. Leer RFCs, entender poll y execve.
● Meta: Tener definidos los .hpp antes de enero. Si no tenemos las clases definidas, no podremos programar por separado.
// Persona 2 entrega a Persona 1
ServerConfig getServerConfig(int port);
// Persona 1 entrega a Persona 3
std::string getRawRequest(int client_fd);
// Persona 3 entrega a Persona 1
std::string getHTTPResponse(HTTPRequest req, ServerConfig config);

Fase 2: Enero - Semanas 3 a 5 (Implementación Dura)
● Vuelta a la rutina. Cada uno implementa su módulo aislado siguiendo la estrategia de Mocks.

Fase 3: Febrero - Semanas 6 y 7 (Integración y CGI)
● Unimos las partes. El Core pasa datos al Parser, el Parser al Router.
● Punto crítico: Debuguear el CGI y los Segfaults al juntar todo.

Fase 4:
-integráis las 3 partes:
- Config → inicializa los sockets
- Sockets → reciben datos y los pasan al parser HTTP
- HTTP → genera responses que los sockets envían
Luego implementáis juntos CGI y features avanzadas.
CGI y features avanzadas
- Implementar CGI (todos juntos, requiere conocer los 3 módulos)
- Chunked transfer encoding
- Optimizaciones

Fase 5: Semana 8 (Pulido)
● Tests de fugas de memoria (Leaks/Valgrind) y cumplimiento de C++98.

-----------------------
Resumen para sobrevivir
1. No programar sin diseño: Definamos las clases primero.
2. No bloquearse esperando al otro: Usad datos falsos para avanzar en vuestra parte.
3. El Frontend: Lo hacemos los tres en una tarde (HTML básico y feo), es lo de menos.
4. Disfrutad las fiestas: Aprovechad ahora para leer documentación. El código duro empieza el 7 de enero



-----------------------------------------------------------------------------------------------
Organización y asignación de roles:

### **Persona 1: Core (Sockets y Conexiones) + Config Parser --> Raúl
### **Persona 2: Parsing y HTTP Protocol Handler --> Sayer
### **Persona 3: Router + CGI + File Handler --> Pau

Ventajas de esta distribución
✅ Persona 1 tiene todo lo necesario desde el inicio (config + sockets)
✅ Persona 2 se enfoca SOLO en el protocolo HTTP (más coherente)
✅ Persona 3 tiene la parte más compleja (CGI) pero trabaja independiente
✅ Menos dependencias cruzadas entre personas
✅ Cada módulo es más autocontenido


--------------------------------
# Desglose detallado por persona

## **Persona 1: Core (Sockets y Conexiones) + Config Parser **
Misión
Inicializar el servidor y mantenerlo vivo aceptando miles de conexiones sin bloquearse.

Tareas
Parser del archivo de configuración (leer, validar, crear estructuras)
Estructura de datos para almacenar la config (servidores virtuales, puertos, rutas, límites)
Setup de sockets (listening sockets) usando la configuración parseada
Implementación de multiplexing (poll/select/epoll)
Gestión de conexiones (accept, read, write)
Timeouts y cierre de conexiones
Gestionar buffers de lectura/escritura

Reto
Parsear y validar un archivo de configuración tipo Nginx
Gestionar que la lectura de sockets no sea bloqueante (manejar datos parciales)

Entregable
Servidor que:
Lee y valida un archivo de configuración
Inicializa sockets según la config
Acepta conexiones y lee datos raw
Pasa los datos raw completos a Persona 2

Herramientas y lenguajes
C++98: Clases ConfigParser, ServerConfig, LocationConfig, Server, Socket
System calls: socket(), bind(), listen(), accept(), poll()/select()
STL: std::vector, std::map, std::string
Bash: Scripts para testear diferentes configs y conexiones

Tiempo estimado
Estudio inicial: 8-10 horas (config parsing + sockets)
Implementación config: 12-16 horas
Implementación sockets: 14-18 horas
Testing integrado: 6-8 horas
Total: 40-52 horas (~5-7 jornadas)


## **Persona 2: Parsing y HTTP Protocol Handler**
Misión
Dar sentido a los bytes que llegan y preparar respuestas HTTP válidas.

Tareas
Parser de requests HTTP (método, URI, headers, body)
Generación de responses HTTP (status codes, headers, body)
Validación de requests según RFC 7230/7231
Manejo de chunked transfer encoding
Gestión de headers (Content-Length, Content-Type, etc.)
Páginas de error (404, 500, 405, etc.)
MIME types para diferentes extensiones

Reto
Leer los RFCs, manejar chunked transfer y validar peticiones HTTP 1.1 correctamente.

Entregable
Sistema que:
Recibe texto raw de Persona 1
Lo convierte en una clase HTTPRequest estructurada
Genera HTTPResponse válidas según el request
Devuelve el response como string a Persona 1 para enviar

Herramientas y lenguajes
C++98: Clases HTTPRequest, HTTPResponse, RequestParser
Bash/Python: Scripts para generar requests de prueba
HTML/CSS: Páginas de error básicas
Herramientas: curl, navegador web

Tiempo estimado
Estudio inicial: 6-8 horas (RFC HTTP, estructura)
Implementación parser: 12-16 horas
Implementación responses: 10-14 horas
Error handling y MIME: 4-6 horas
Total: 32-44 horas (~4-6 jornadas)


## **Persona 3: Router + CGI + File Handler**
Misión
Decidir qué hacer con la petición (servir archivo, borrarlo o ejecutar script).

Tareas
Implementar la lógica de rutas (routing según configuración)
Manejo de métodos GET (servir archivos estáticos, directory listing)
Manejo de métodos POST (upload de archivos)
Manejo de métodos DELETE (borrar archivos)
Sistema CGI completo (fork, pipes, execve)
Gestión de permisos y validaciones de seguridad
Manejo de redirecciones

Reto
Conectar la entrada/salida de los scripts CGI sin crear zombies ni bloqueos.

Entregable
Sistema que:
Recibe HTTPRequest de Persona 2
Consulta la config de Persona 1 para saber qué hacer
Ejecuta la acción (servir archivo, CGI, delete)
Devuelve el body del response a Persona 2

Herramientas y lenguajes
C++98: Clases RequestHandler, CGIHandler, FileManager
System calls: fork(), pipe(), dup2(), execve(), waitpid()
PHP/Python: Scripts CGI de prueba
Bash: Scripts de testing

Tiempo estimado
Estudio inicial: 5-7 horas (CGI, file handling)
Implementación GET/POST/DELETE: 12-16 horas
Implementación CGI: 16-22 horas (la parte más difícil)
Testing y debugging: 8-10 horas
Total: 41-55 horas (~5-7 jornadas)


-----------------------------------------------------------------------------------------------
Flujo de trabajo integrado:

┌─────────────────────────────────────────────────────────┐
│ PERSONA 1: Core + Config                                │
│ ┌─────────────┐    ┌──────────────┐                     │
│ │ Config File │───>│ ConfigParser │                     │
│ └─────────────┘    └──────┬───────┘                     │
│                           │                             │
│                           v                             │
│                     ┌─────────────┐                     │
│                     │ServerConfig │                     │
│                     └──────┬──────┘                     │
│                            │                            │
│                            v                            │
│      ┌──────────────────────────────────┐               │
│      │  Server (poll/sockets/buffers)   │               │
│      └─────────┬────────────────────────┘               │
└────────────────┼────────────────────────────────────────┘
                 │ raw request data
                 v
┌─────────────────────────────────────────────────────────┐
│ PERSONA 2: HTTP Protocol                                │
│      ┌──────────────┐                                   │
│      │ RequestParser│                                   │
│      └──────┬───────┘                                   │
│             │                                           │
│             v                                           │
│      ┌─────────────┐                                    │
│      │HTTPRequest  │──────────────────┐                 │
│      └─────────────┘                  │                 │
└───────────────────────────────────────┼─────────────────┘
                                        │
                                        v
┌─────────────────────────────────────────────────────────┐
│ PERSONA 3: Router + CGI                                 │
│      ┌──────────────────┐                               │
│      │ RequestHandler   │                               │
│      │  - GET/POST/DEL  │                               │
│      │  - CGI execution │                               │
│      └────────┬─────────┘                               │
│               │ response body                           │
└───────────────┼─────────────────────────────────────────┘
                v
┌─────────────────────────────────────────────────────────┐
│ PERSONA 2: HTTP Protocol                                │
│      ┌──────────────┐                                   │
│      │HTTPResponse  │                                   │
│      └──────┬───────┘                                   │
│             │ formatted HTTP response                   │
└─────────────┼───────────────────────────────────────────┘
              v
┌─────────────────────────────────────────────────────────┐
│ PERSONA 1: Core                                         │
│      ┌──────────────┐                                   │
│      │Server::send()│                                   │
│      └──────────────┘                                   │
└─────────────────────────────────────────────────────────┘

